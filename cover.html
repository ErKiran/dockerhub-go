
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>dockerhub-go: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/ErKiran/dockerhub-go/auth.go (81.8%)</option>
				
				<option value="file1">github.com/ErKiran/dockerhub-go/dockerhub.go (79.5%)</option>
				
				<option value="file2">github.com/ErKiran/dockerhub-go/http.go (75.0%)</option>
				
				<option value="file3">github.com/ErKiran/dockerhub-go/organization.go (76.5%)</option>
				
				<option value="file4">github.com/ErKiran/dockerhub-go/repositories.go (75.0%)</option>
				
				<option value="file5">github.com/ErKiran/dockerhub-go/tag.go (0.0%)</option>
				
				<option value="file6">github.com/ErKiran/dockerhub-go/user.go (75.0%)</option>
				
				<option value="file7">github.com/ErKiran/dockerhub-go/util.go (25.0%)</option>
				
				<option value="file8">github.com/ErKiran/dockerhub-go/webhook.go (55.6%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package dockerhub

import (
        "context"
        "errors"
        "net/http"
)

// AuthService handles communication with the auth related
// methods of the Dockerhub API.
type AuthService service

// LoginRequest represents the payload to be sent to login to the
// Dockerhub API.
type LoginRequest struct {
        Username string `json:"username"`
        Password string `json:"password"`
}

// LoginResponse represents the payload to be responded to a successful
// Dockerhub API login request.
type LoginResponse struct {
        Token string `json:"token"`
}

// Login authenticates with the Dockerhub API with the given given
// username and password.
func (s *AuthService) Login(ctx context.Context, username, password string) error <span class="cov8" title="1">{
        p := &amp;LoginRequest{username, password}
        req, err := s.client.NewRequest(http.MethodPost, "/users/login/", p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">res := &amp;LoginResponse{}
        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(res.Token) == 0 </span><span class="cov8" title="1">{
                return errors.New("Did not recieve token")
        }</span>

        <span class="cov8" title="1">s.client.SetAuthToken(res.Token)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package dockerhub

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "net/http"
        "net/url"
)

const (
        defaultUserAgent       = "dockerhub-go/v1"
        defaultAPIBaseURL      = "https://hub.docker.com"
        defaultAPIBaseEndpoint = "/v2"
)

// A Client manages communication with the Dockerhub API.
type Client struct {
        httpClient *http.Client
        BaseURL    *url.URL
        UserAgent  string

        authToken string

        common service

        Auth         *AuthService
        Repositories *RepositoriesService
        User         *UserService
        Webhook      *WebhookService
        Organization *OrganizationService
        Tag          *TagService
}

// NewClient returns a new Dockerhub client. If an httpClient is not
// provided, a new http.Client will be used.
func NewClient(httpClient *http.Client) *Client <span class="cov8" title="1">{
        if httpClient == nil </span><span class="cov8" title="1">{
                httpClient = &amp;http.Client{}
        }</span>

        <span class="cov8" title="1">baseURL, _ := url.Parse(defaultAPIBaseURL)

        c := &amp;Client{
                httpClient: httpClient,
                UserAgent:  defaultUserAgent,
                BaseURL:    baseURL,
        }
        c.common.client = c
        c.Auth = (*AuthService)(&amp;c.common)
        c.Repositories = (*RepositoriesService)(&amp;c.common)
        c.User = (*UserService)(&amp;c.common)
        c.Webhook = (*WebhookService)(&amp;c.common)
        c.Organization = (*OrganizationService)(&amp;c.common)
        c.Tag = (*TagService)(&amp;c.common)
        return c</span>
}

type service struct {
        client *Client
}

// SetAuthToken sets the Authorization token on the client to be sent with
// API requests.
func (c *Client) SetAuthToken(token string) <span class="cov8" title="1">{
        c.authToken = token
}</span>

// Do sends an API request and returns the API response. The API response is JSON
// decoded and stored in the value pointed to by v.
func (c *Client) Do(ctx context.Context, req *http.Request, v interface{}) (*http.Response, error) <span class="cov8" title="1">{
        req = req.WithContext(ctx)
        resp, err := c.httpClient.Do(req)

        if err != nil </span><span class="cov0" title="0">{
                select </span>{
                case &lt;-ctx.Done():<span class="cov0" title="0">
                        return nil, ctx.Err()</span>
                default:<span class="cov0" title="0"></span>
                }

                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov8" title="1">defer resp.Body.Close()

        if err := checkResponse(resp); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := json.NewDecoder(resp.Body).Decode(v); err != nil &amp;&amp; err != io.EOF </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return resp, nil</span>
}

// NewRequest creates an API request. The given URL is relative to the Client's
// BaseURL.
func (c *Client) NewRequest(method, url string, body interface{}) (*http.Request, error) <span class="cov8" title="1">{
        u, err := c.BaseURL.Parse(defaultAPIBaseEndpoint + url)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var buf io.ReadWriter
        if body != nil </span><span class="cov8" title="1">{
                buf = new(bytes.Buffer)
                enc := json.NewEncoder(buf)
                enc.SetEscapeHTML(false)
                if err := enc.Encode(body); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">req, err := http.NewRequest(method, u.String(), buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(c.authToken) != 0 </span><span class="cov0" title="0">{
                req.Header.Set("Authorization", fmt.Sprintf("JWT %s", c.authToken))
        }</span>

        <span class="cov8" title="1">if body != nil </span><span class="cov8" title="1">{
                req.Header.Set("Content-Type", "application/json")
        }</span>

        <span class="cov8" title="1">req.Header.Set("User-Agent", c.UserAgent)
        return req, nil</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package dockerhub

import (
        "fmt"
        "net/http"
)

// checkResponse checks a given HTTP response for errors and returns
// them if present.
func checkResponse(r *http.Response) error <span class="cov8" title="1">{
        status := r.StatusCode
        if status &gt;= 200 &amp;&amp; status &lt;= 299 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return fmt.Errorf("Request failed with status %d", status)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package dockerhub

import (
        "context"
        "fmt"
        "net/http"
        "time"
)

type OrganizationService service

type CreateOrganizationRequest struct {
        Orgname string `json:"orgname"`
        Company string `json:"company"`
}

type Organization struct {
        ID            string    `json:"id"`
        Orgname       string    `json:"orgname"`
        FullName      string    `json:"full_name"`
        Location      string    `json:"location"`
        Company       string    `json:"company"`
        ProfileURL    string    `json:"profile_url"`
        DateJoined    time.Time `json:"date_joined"`
        GravatarURL   string    `json:"gravatar_url"`
        GravatarEmail string    `json:"gravatar_email"`
        Type          string    `json:"type"`
}

type OrganizationList struct {
        Count    int         `json:"count"`
        Next     interface{} `json:"next"`
        Previous interface{} `json:"previous"`
        Results  []struct {
                ID            string    `json:"id"`
                Orgname       string    `json:"orgname"`
                FullName      string    `json:"full_name"`
                Location      string    `json:"location"`
                Company       string    `json:"company"`
                ProfileURL    string    `json:"profile_url"`
                DateJoined    time.Time `json:"date_joined"`
                GravatarURL   string    `json:"gravatar_url"`
                GravatarEmail string    `json:"gravatar_email"`
                Type          string    `json:"type"`
        } `json:"results"`
}

// Create organizations
func (s *OrganizationService) CreateOrganization(ctx context.Context, organization, company string) (*Organization, error) <span class="cov8" title="1">{
        url := "/orgs/"
        org := CreateOrganizationRequest{
                Orgname: organization,
                Company: company,
        }

        req, err := s.client.NewRequest(http.MethodPost, url, org)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;Organization{}

        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

// Get all organizations of user
func (s *OrganizationService) GetOrganizations(ctx context.Context, pageSize int) (*OrganizationList, error) <span class="cov8" title="1">{
        slug := fmt.Sprintf("/user/orgs/?page_size=%d", pageSize)
        req, err := s.client.NewRequest(http.MethodGet, slug, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;OrganizationList{}
        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package dockerhub

import (
        "context"
        "fmt"
        "net/http"
)

// RepositoriesService handles communication with the repository
// related methods of the Dockerhub API.
type RepositoriesService service

// RepositoryPatch represents payload to patch a Repository.
type RepositoryPatch struct {
        FullDescription string `json:"full_description,omitempty"`
        Description     string `json:"description,omitempty"`
}

// RepositoryPrivacyPatch represents payload to patch a Repository's
// privacy mode.
type RepositoryPrivacyPatch struct {
        IsPrivate bool `json:"is_private"`
}

// RepositoryPermissions specifies the permissions of the requesting user
// to the given Repository.
type RepositoryPermissions struct {
        Read  bool `json:"read"`
        Write bool `json:"write"`
        Admin bool `json:"admin"`
}

// RepositoryList represents a list of repositories with pagination details.
type RepositoryList struct {
        Count    int     `json:"count"`
        Next     *string `json:"next"`
        Previous *string `json:"previous"`

        Results []Repository `json:"results"`
}

// Repository represents a Dockerhub repository.
type Repository struct {
        User            string  `json:"user"`
        Name            string  `json:"name"`
        Namespace       string  `json:"namespace"`
        RepositoryType  string  `json:"repository_type"`
        Status          int     `json:"status"`
        Description     string  `json:"description"`
        IsPrivate       bool    `json:"is_private"`
        IsAutomated     bool    `json:"is_automated"`
        CanEdit         bool    `json:"can_edit"`
        StarCount       int     `json:"star_count"`
        PullCount       int     `json:"pull_count"`
        LastUpdated     string  `json:"last_updated"`
        IsMigrated      bool    `json:"is_migrated"`
        HasStarred      bool    `json:"has_starred"`
        FullDescription string  `json:"full_description"`
        Affiliation     *string `json:"affiliation"`

        Permissions RepositoryPermissions `json:"repository_permissions"`
}

type CreateRepositoryRequest struct {
        Namespace     string        `json:"namespace"`
        Registry      string        `json:"registry"`
        Image         string        `json:"image"`
        Name          string        `json:"name"`
        Description   string        `json:"description"`
        Privacy       string        `json:"privacy"`
        BuildSettings []interface{} `json:"build_settings"`
        IsPrivate     bool          `json:"is_private"`
}

func (s RepositoriesService) buildRepoSlug(namespace, repo string) string <span class="cov8" title="1">{
        return fmt.Sprintf("/repositories/%s/%s/", namespace, repo)
}</span>

// CreateRepository create a repository.
func (s *RepositoriesService) CreateRepository(ctx context.Context, namespace, name, description string, isPrivate bool) (*Repository, error) <span class="cov8" title="1">{
        url := "/repositories/"
        repo := &amp;CreateRepositoryRequest{
                Namespace:   namespace,
                Name:        name,
                Description: description,
                IsPrivate:   isPrivate,
                Registry:    "docker",
                Image:       fmt.Sprintf("%s/%s", namespace, name),
        }

        if repo.IsPrivate </span><span class="cov0" title="0">{
                repo.Privacy = "private"
        }</span> else<span class="cov8" title="1"> {
                repo.Privacy = "public"
        }</span>

        <span class="cov8" title="1">req, err := s.client.NewRequest(http.MethodPost, url, repo)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;Repository{}

        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

// EditRepository updates a repository.
func (s *RepositoriesService) EditRepository(ctx context.Context, namespace, repo string, patch *RepositoryPatch) (*Repository, error) <span class="cov8" title="1">{
        slug := s.buildRepoSlug(namespace, repo)
        req, err := s.client.NewRequest(http.MethodPatch, slug, patch)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;Repository{}
        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

// GetRepository gets details for a given repository.
func (s *RepositoriesService) GetRepository(ctx context.Context, namespace, repo string) (*Repository, error) <span class="cov8" title="1">{
        slug := s.buildRepoSlug(namespace, repo)
        req, err := s.client.NewRequest(http.MethodGet, slug, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;Repository{}
        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}

// SetRepositoryPrivacy sets the privacy status of a repository.
func (s *RepositoriesService) SetRepositoryPrivacy(ctx context.Context, namespace, repo string, isPrivate bool) error <span class="cov8" title="1">{
        slug := s.buildRepoSlug(namespace, repo) + "privacy/"
        req, err := s.client.NewRequest(http.MethodPost, slug, &amp;RepositoryPrivacyPatch{
                IsPrivate: isPrivate,
        })
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := s.client.Do(ctx, req, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetRepositories gets all repositories from a given Dockerhub namespace.
func (s *RepositoriesService) GetRepositories(ctx context.Context, namespace string) (*RepositoryList, error) <span class="cov8" title="1">{
        slug := fmt.Sprintf("/repositories/%s/", namespace)
        req, err := s.client.NewRequest(http.MethodGet, slug, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;RepositoryList{}
        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">package dockerhub

import (
        "context"
        "fmt"
        "net/http"
        "time"
)

type TagService service

type Tags struct {
        Count    int         `json:"count"`
        Next     interface{} `json:"next"`
        Previous interface{} `json:"previous"`
        Results  []struct {
                Creator int         `json:"creator"`
                ID      int         `json:"id"`
                ImageID interface{} `json:"image_id"`
                Images  []struct {
                        Architecture string      `json:"architecture"`
                        Features     string      `json:"features"`
                        Variant      interface{} `json:"variant"`
                        Digest       string      `json:"digest"`
                        Os           string      `json:"os"`
                        OsFeatures   string      `json:"os_features"`
                        OsVersion    interface{} `json:"os_version"`
                        Size         int         `json:"size"`
                        Status       string      `json:"status"`
                        LastPulled   time.Time   `json:"last_pulled"`
                        LastPushed   time.Time   `json:"last_pushed"`
                } `json:"images"`
                LastUpdated         time.Time `json:"last_updated"`
                LastUpdater         int       `json:"last_updater"`
                LastUpdaterUsername string    `json:"last_updater_username"`
                Name                string    `json:"name"`
                Repository          int       `json:"repository"`
                FullSize            int       `json:"full_size"`
                V2                  bool      `json:"v2"`
                TagStatus           string    `json:"tag_status"`
                TagLastPulled       time.Time `json:"tag_last_pulled"`
                TagLastPushed       time.Time `json:"tag_last_pushed"`
        } `json:"results"`
}

func (s *TagService) GetTags(ctx context.Context, namespace, repo string, page int) (*Tags, error) <span class="cov0" title="0">{
        slug := fmt.Sprintf("/repositories/%v/%v/tags/?page_size=%d&amp;ordering=last_updated", namespace, repo, page)

        req, err := s.client.NewRequest(http.MethodGet, slug, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">res := &amp;Tags{}
        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package dockerhub

import (
        "context"
        "net/http"
        "time"
)

type UserService service

type User struct {
        ID            string    `json:"id"`
        Username      string    `json:"username"`
        FullName      string    `json:"full_name"`
        Location      string    `json:"location"`
        Company       string    `json:"company"`
        GravatarEmail string    `json:"gravatar_email"`
        IsStaff       bool      `json:"is_staff"`
        IsAdmin       bool      `json:"is_admin"`
        ProfileURL    string    `json:"profile_url"`
        DateJoined    time.Time `json:"date_joined"`
        GravatarURL   string    `json:"gravatar_url"`
        Type          string    `json:"type"`
}

func (s *UserService) GetLoggedInUser(ctx context.Context) (*User, error) <span class="cov8" title="1">{
        url := "/user/"

        req, err := s.client.NewRequest(http.MethodGet, url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;User{}

        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return res, nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package dockerhub

// String returns a pointer to a string for configuration.
func String(s string) *string <span class="cov8" title="1">{
        return &amp;s
}</span>

// StringValue returns the value of a String pointer
func StringValue(s *string) string <span class="cov0" title="0">{
        if s != nil </span><span class="cov0" title="0">{
                return *s
        }</span>
        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package dockerhub

import (
        "context"
        "fmt"
        "net/http"
        "time"
)

type WebhookService service

type Webhooks struct {
        Name        string    `json:"name"`
        HookURL     string    `json:"hook_url"`
        Created     time.Time `json:"created"`
        LastUpdated time.Time `json:"last_updated"`
}

type Results struct {
        Name                string     `json:"name"`
        Slug                string     `json:"slug"`
        ExpectFinalCallback bool       `json:"expect_final_callback"`
        Created             time.Time  `json:"created"`
        LastUpdated         time.Time  `json:"last_updated"`
        Webhooks            []Webhooks `json:"webhooks"`
}

type WebhookRequest struct {
        Name                string     `json:"name"`
        ExpectFinalCallback bool       `json:"expect_final_callback"`
        Webhooks            []Webhooks `json:"webhooks"`
        Registry            string     `json:"registry"`
}

type Autogenerated struct {
        Count    int         `json:"count"`
        Next     interface{} `json:"next"`
        Previous interface{} `json:"previous"`
        Results  []struct {
                Name                string `json:"name"`
                Slug                string `json:"slug"`
                ExpectFinalCallback bool   `json:"expect_final_callback"`
                Webhooks            []struct {
                        Name        string    `json:"name"`
                        HookURL     string    `json:"hook_url"`
                        Created     time.Time `json:"created"`
                        LastUpdated time.Time `json:"last_updated"`
                } `json:"webhooks"`
                Created     time.Time `json:"created"`
                LastUpdated time.Time `json:"last_updated"`
        } `json:"results"`
}

type WebhookResponse struct {
        Count    int         `json:"count"`
        Next     interface{} `json:"next"`
        Previous interface{} `json:"previous"`
        Results  []Results   `json:"results"`
}

func (s WebhookService) buildWebhookSlug(namespace, repo string) string <span class="cov8" title="1">{
        return fmt.Sprintf("/repositories/%s/%s/webhook_pipeline/", namespace, repo)
}</span>
func (s *WebhookService) CreateWebhook(ctx context.Context, namespace, repo, name, url string) (*WebhookResponse, error) <span class="cov8" title="1">{
        slug := s.buildWebhookSlug(namespace, repo)

        hook := &amp;WebhookRequest{
                Name:                name,
                ExpectFinalCallback: false,
                Registry:            "registry-1.docker.io",
        }

        hook.Webhooks = append(hook.Webhooks, Webhooks{
                Name:    name,
                HookURL: url,
        })

        req, err := s.client.NewRequest(http.MethodPost, slug, hook)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">res := &amp;WebhookResponse{}

        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

func (s *WebhookService) GetWebhooks(ctx context.Context, namespace, repo string) (*WebhookResponse, error) <span class="cov8" title="1">{
        slug := s.buildWebhookSlug(namespace, repo)

        req, err := s.client.NewRequest(http.MethodGet, slug, nil)

        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">res := &amp;WebhookResponse{}

        if _, err := s.client.Do(ctx, req, res); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return res, nil</span>
}

func (s *WebhookService) DeleteWebhook(ctx context.Context, namespace, repo, name string) error <span class="cov0" title="0">{
        slug := s.buildWebhookSlug(namespace, repo)

        webhookURL := fmt.Sprintf("%s%s/", slug, name)

        req, err := s.client.NewRequest(http.MethodDelete, webhookURL, nil)

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if _, err := s.client.Do(ctx, req, nil); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
