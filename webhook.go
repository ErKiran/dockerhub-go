package dockerhub

import (
	"context"
	"fmt"
	"net/http"
	"time"
)

// WebhookService Type
type WebhookService service

// Webhooks Payload
type Webhooks struct {
	Name        string    `json:"name"`
	HookURL     string    `json:"hook_url"`
	Created     time.Time `json:"created"`
	LastUpdated time.Time `json:"last_updated"`
}

// Results Response
type Results struct {
	Name                string     `json:"name"`
	Slug                string     `json:"slug"`
	ExpectFinalCallback bool       `json:"expect_final_callback"`
	Created             time.Time  `json:"created"`
	LastUpdated         time.Time  `json:"last_updated"`
	Webhooks            []Webhooks `json:"webhooks"`
}

// WebhookRequest payload
type WebhookRequest struct {
	Name                string     `json:"name"`
	ExpectFinalCallback bool       `json:"expect_final_callback"`
	Webhooks            []Webhooks `json:"webhooks"`
	Registry            string     `json:"registry"`
}

// Autogenerated Response of webhook
type Autogenerated struct {
	Count    int         `json:"count"`
	Next     interface{} `json:"next"`
	Previous interface{} `json:"previous"`
	Results  []struct {
		Name                string `json:"name"`
		Slug                string `json:"slug"`
		ExpectFinalCallback bool   `json:"expect_final_callback"`
		Webhooks            []struct {
			Name        string    `json:"name"`
			HookURL     string    `json:"hook_url"`
			Created     time.Time `json:"created"`
			LastUpdated time.Time `json:"last_updated"`
		} `json:"webhooks"`
		Created     time.Time `json:"created"`
		LastUpdated time.Time `json:"last_updated"`
	} `json:"results"`
}

// WebhookResponse Response of webhook
type WebhookResponse struct {
	Count    int         `json:"count"`
	Next     interface{} `json:"next"`
	Previous interface{} `json:"previous"`
	Results  []Results   `json:"results"`
}

func (s WebhookService) buildWebhookSlug(namespace, repo string) string {
	return fmt.Sprintf("/repositories/%s/%s/webhook_pipeline/", namespace, repo)
}

// CreateWebhook create webhook for the triggers
func (s *WebhookService) CreateWebhook(ctx context.Context, namespace, repo, name, url string) (*WebhookResponse, error) {
	slug := s.buildWebhookSlug(namespace, repo)

	hook := &WebhookRequest{
		Name:                name,
		ExpectFinalCallback: false,
		Registry:            "registry-1.docker.io",
	}

	hook.Webhooks = append(hook.Webhooks, Webhooks{
		Name:    name,
		HookURL: url,
	})

	req, err := s.client.NewRequest(http.MethodPost, slug, hook)
	if err != nil {
		return nil, err
	}

	res := &WebhookResponse{}

	if _, err := s.client.Do(ctx, req, res); err != nil {
		return nil, err
	}
	return res, nil
}

// GetWebhooks Get the related webhooks
func (s *WebhookService) GetWebhooks(ctx context.Context, namespace, repo string) (*WebhookResponse, error) {
	slug := s.buildWebhookSlug(namespace, repo)

	req, err := s.client.NewRequest(http.MethodGet, slug, nil)
	if err != nil {
		return nil, err
	}
	res := &WebhookResponse{}

	if _, err := s.client.Do(ctx, req, res); err != nil {
		return nil, err
	}
	return res, nil
}

// DeleteWebhook Delete the existing webhooks
func (s *WebhookService) DeleteWebhook(ctx context.Context, namespace, repo, name string) error {
	slug := s.buildWebhookSlug(namespace, repo)

	webhookURL := fmt.Sprintf("%s%s/", slug, name)

	req, err := s.client.NewRequest(http.MethodDelete, webhookURL, nil)
	if err != nil {
		return err
	}
	if _, err := s.client.Do(ctx, req, nil); err != nil {
		return err
	}
	return nil
}
